<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æ‰‹åŠ¿ç”»æ¿</title>
    <!-- å¼•å…¥ MediaPipe -->
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body { margin: 0; background-color: #1a1a1a; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        #container { position: relative; width: 100vw; height: 100vh; }

        /* ç”»å¸ƒå±‚çº§ */
        canvas { position: absolute; top: 0; left: 0; }
        #video_canvas { z-index: 0; transform: scaleX(-1); opacity: 0.6; } /* è§†é¢‘åŠé€æ˜ï¼Œçªå‡ºéª¨éª¼ */
        #bone_canvas { z-index: 1; transform: scaleX(-1); pointer-events: none; } /* éª¨éª¼å±‚ï¼Œä¹Ÿéœ€è¦é•œåƒ */
        #drawing_canvas { z-index: 2; } /* ç”»ä½œå±‚ */
        #cursor_canvas { z-index: 3; pointer-events: none; } /* å…‰æ ‡å±‚ */

        /* æç¤ºé®ç½© */
        #overlay-msg {
            position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%);
            z-index: 50; color: white; font-size: 2rem; font-weight: bold;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8); text-align: center;
            pointer-events: none; transition: opacity 0.5s;
        }

        /* çŠ¶æ€æ  */
        #status {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            z-index: 20; background: rgba(0,0,0,0.7); color: #00ff88;
            padding: 8px 20px; border-radius: 20px; font-size: 16px; pointer-events: none;
            border: 1px solid rgba(0,255,136,0.3);
        }

        /* åº•éƒ¨å·¥å…·æ  */
        .toolbar-container {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            z-index: 10; display: flex; flex-direction: column; gap: 15px; align-items: center;
        }

        .brush-menu, .main-menu {
            background: rgba(40, 40, 40, 0.95);
            padding: 10px 20px; border-radius: 30px;
            display: flex; gap: 15px; align-items: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .divider { width: 1px; height: 30px; background: rgba(255,255,255,0.2); }

        .btn {
            width: 50px; height: 50px; border-radius: 50%;
            background: rgba(255,255,255,0.1);
            color: white; font-size: 22px; position: relative;
            cursor: pointer; display: flex; justify-content: center; align-items: center;
            transition: all 0.2s; overflow: hidden;
        }
        
        .btn:hover { transform: scale(1.1); background: rgba(255,255,255,0.3); }
        .btn.active { background: rgba(0, 255, 136, 0.3); color: #00ff88; border: 2px solid #00ff88; }
        .btn-small { width: 40px; height: 40px; font-size: 18px; }

        /* é¢œè‰²é€‰æ‹©å™¨ */
        input[type=color] {
            width: 150%; height: 150%; border: none; background: none;
            position: absolute; left: -25%; top: -25%; cursor: pointer;
        }

        /* æ‚¬åœåŠ¨ç”»ç¯ */
        .progress-ring {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 50%; border: 3px solid transparent;
            border-top-color: #00ff88; display: none;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="container">
        <video id="input_video" style="display:none"></video>
        <canvas id="video_canvas"></canvas>
        <canvas id="bone_canvas"></canvas> <!-- éª¨éª¼ç»˜åˆ¶å±‚ -->
        <canvas id="drawing_canvas"></canvas>
        <canvas id="cursor_canvas"></canvas>
    </div>

    <div id="overlay-msg">ğŸ‘ˆ è¯·å…ˆåœ¨ä¸‹æ–¹é€‰æ‹©ä¸€æ”¯ç”»ç¬”</div>
    <div id="status">åˆå§‹åŒ–ä¸­...</div>

    <div class="toolbar-container">
        <!-- ç”»ç¬”æè´¨ -->
        <div class="brush-menu">
            <div class="btn btn-small interactive" id="brush-pen" onclick="selectBrush('pen')" title="é’¢ç¬”">ğŸ–Šï¸<div class="progress-ring"></div></div>
            <div class="btn btn-small interactive" id="brush-pencil" onclick="selectBrush('pencil')" title="é“…ç¬”">âœï¸<div class="progress-ring"></div></div>
            <div class="btn btn-small interactive" id="brush-watercolor" onclick="selectBrush('watercolor')" title="æ°´å½©">ğŸ–Œï¸<div class="progress-ring"></div></div>
            <div class="btn btn-small interactive" id="brush-marker" onclick="selectBrush('marker')" title="é©¬å…‹ç¬”">ğŸ–ï¸<div class="progress-ring"></div></div>
        </div>

        <!-- ä¸»æ§æ  -->
        <div class="main-menu">
            <div class="btn interactive">
                <input type="color" id="colorPicker" value="#ffffff">
                <div class="progress-ring"></div>
            </div>
            
            <div class="btn interactive" onclick="changeSize(-2)">â–<div class="progress-ring"></div></div>
            <div class="btn interactive" onclick="changeSize(2)">â•<div class="progress-ring"></div></div>

            <div class="divider"></div>

            <div class="btn interactive active" id="mode-draw" onclick="setMode('draw')">ğŸ¨<div class="progress-ring"></div></div>
            <div class="btn interactive" id="mode-move" onclick="setMode('move')">âœ‹<div class="progress-ring"></div></div>

            <div class="divider"></div>

            <div class="btn interactive" onclick="clearCanvas()">ğŸ—‘ï¸<div class="progress-ring"></div></div>
            <div class="btn interactive" onclick="saveCanvas()">ğŸ’¾<div class="progress-ring"></div></div>
            <div class="btn interactive" onclick="window.location.href='index.html'">ğŸ <div class="progress-ring"></div></div>
        </div>
    </div>

    <script>
        // --- æ ¸å¿ƒé…ç½® ---
        const SMOOTHING_FACTOR = 0.15; // å¹³æ»‘ç³»æ•° (0.1-0.3 ä¹‹é—´ï¼Œè¶Šå°è¶Šå¹³æ»‘ä½†å»¶è¿Ÿè¶Šé«˜)
        const PINCH_THRESHOLD = 0.06; // æåˆåˆ¤å®šé˜ˆå€¼ (æ ¹æ®æ‰‹è·è°ƒæ•´)
        
        // --- DOM & Context ---
        const videoElement = document.getElementById('input_video');
        const canvases = {
            vid: document.getElementById('video_canvas').getContext('2d'),
            bone: document.getElementById('bone_canvas').getContext('2d'),
            draw: document.getElementById('drawing_canvas').getContext('2d'),
            cursor: document.getElementById('cursor_canvas').getContext('2d')
        };
        const overlayMsg = document.getElementById('overlay-msg');
        const statusEl = document.getElementById('status');

        // --- çŠ¶æ€å˜é‡ ---
        let state = {
            mode: 'draw', // draw | move
            brushType: null, // åˆå§‹ä¸º nullï¼Œå¿…é¡»é€‰æ‹©
            brushSize: 6,
            color: '#ffffff',
            isPinching: false,
            hasStarted: false // æ˜¯å¦å·²é€‰æ‹©ç”»ç¬”
        };

        // å¹³æ»‘åæ ‡
        let currPos = { x: 0, y: 0 }; // å½“å‰å¹³æ»‘åçš„åæ ‡
        let rawPos = { x: 0, y: 0 };  // åŸå§‹æ£€æµ‹åæ ‡
        let prevPos = { x: 0, y: 0 }; // ä¸Šä¸€å¸§åæ ‡

        // ç§»åŠ¨ç”»å¸ƒåç§»é‡
        let offset = { x: 0, y: 0 };
        let startPinchPos = { x: 0, y: 0 };

        // äº¤äº’è®¡æ—¶å™¨
        let hoverTimer = null;
        let hoverTarget = null;

        // ç”»ç¬”å‚æ•°
        const BRUSHES = {
            pen: { alpha: 1, widthMult: 1, cap: 'round', shadow: 0, name: 'é’¢ç¬”' },
            pencil: { alpha: 0.9, widthMult: 0.5, cap: 'round', shadow: 0, name: 'é“…ç¬”' },
            watercolor: { alpha: 0.15, widthMult: 3, cap: 'round', shadow: 10, name: 'æ°´å½©' },
            marker: { alpha: 0.6, widthMult: 2.5, cap: 'square', shadow: 0, name: 'é©¬å…‹ç¬”' }
        };

        // --- åˆå§‹åŒ–å°ºå¯¸ ---
        function resize() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            Object.values(document.querySelectorAll('canvas')).forEach(c => { c.width = w; c.height = h; });
            canvases.draw.lineJoin = 'round';
            canvases.draw.lineCap = 'round';
        }
        window.onresize = resize;
        resize();

        // --- ç®—æ³•å·¥å…· ---
        function lerp(start, end, amt) {
            return (1 - amt) * start + amt * end;
        }

        function distance(p1, p2) {
            return Math.hypot(p1.x - p2.x, p1.y - p2.y);
        }

        // --- ä¸šåŠ¡é€»è¾‘ ---
        function selectBrush(type) {
            state.brushType = type;
            state.hasStarted = true;
            overlayMsg.style.opacity = 0; // éšè—æç¤º
            
            document.querySelectorAll('.brush-menu .btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`brush-${type}`).classList.add('active');
            
            statusEl.innerText = `å½“å‰: ${BRUSHES[type].name} | æåˆé£ŸæŒ‡æ‹‡æŒ‡å¼€å§‹ä¹¦å†™`;
        }

        function setMode(m) {
            state.mode = m;
            document.querySelectorAll('#mode-draw, #mode-move').forEach(b => b.classList.remove('active'));
            document.getElementById(`mode-${m}`).classList.add('active');
            statusEl.innerText = m === 'draw' ? "ğŸ¨ ç»˜ç”»æ¨¡å¼: æåˆå†™å­—ï¼Œå¼ å¼€æ‚¬åœ" : "âœ‹ ç§»åŠ¨æ¨¡å¼: æåˆæŠ“å–ç”»å¸ƒ";
        }

        function changeSize(delta) {
            state.brushSize = Math.max(2, Math.min(50, state.brushSize + delta));
            statusEl.innerText = `ç¬”åˆ·å¤§å°: ${state.brushSize}`;
        }

        function clearCanvas() {
            canvases.draw.clearRect(0, 0, window.innerWidth, window.innerHeight);
            offset = { x: 0, y: 0 };
            document.getElementById('drawing_canvas').style.transform = `none`;
        }

        function saveCanvas() {
            const link = document.createElement('a');
            link.download = 'gesture_art.png';
            link.href = document.getElementById('drawing_canvas').toDataURL();
            link.click();
        }

        // --- äº¤äº’ä¸æ‚¬åœæ£€æµ‹ ---
        function updateHover(x, y) {
            const els = document.elementsFromPoint(x, y);
            let target = null;
            
            // æŸ¥æ‰¾ interactive æŒ‰é’®
            for (let el of els) {
                if (el.classList.contains('interactive')) { target = el; break; }
                if (el.parentElement?.classList.contains('interactive')) { target = el.parentElement; break; }
            }

            if (target) {
                if (hoverTarget !== target) {
                    resetHover();
                    hoverTarget = target;
                    const ring = target.querySelector('.progress-ring');
                    if (ring) ring.style.display = 'block';
                    
                    // 1ç§’åè§¦å‘ç‚¹å‡»
                    hoverTimer = setTimeout(() => {
                        target.click();
                        // ç‚¹å‡»åŠ¨ç”»åé¦ˆ
                        target.style.transform = 'scale(0.9)';
                        setTimeout(() => target.style.transform = '', 150);
                        resetHover();
                    }, 1000);
                }
            } else {
                resetHover();
            }
        }

        function resetHover() {
            if (hoverTarget) {
                const ring = hoverTarget.querySelector('.progress-ring');
                if (ring) ring.style.display = 'none';
            }
            clearTimeout(hoverTimer);
            hoverTarget = null;
        }

        // --- ä¸»å¾ªç¯ ---
        function onResults(results) {
            // 1. ç»˜åˆ¶è§†é¢‘åº•å›¾
            canvases.vid.clearRect(0, 0, window.innerWidth, window.innerHeight);
            canvases.vid.drawImage(results.image, 0, 0, window.innerWidth, window.innerHeight);

            // 2. ç»˜åˆ¶æ‰‹éƒ¨éª¨éª¼ (åœ¨ bone_canvas å±‚ï¼Œå› ä¸º CSS ç¿»è½¬äº†ï¼Œæ‰€ä»¥ç›´æ¥ç”» landmarks å³å¯)
            canvases.bone.clearRect(0, 0, window.innerWidth, window.innerHeight);
            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(canvases.bone, landmarks, HAND_CONNECTIONS, 
                                 {color: '#00FF00', lineWidth: 2});
                    drawLandmarks(canvases.bone, landmarks, 
                                {color: '#FF0000', lineWidth: 1, radius: 3});
                }
            }

            // 3. æ¸…ç©ºå…‰æ ‡å±‚
            canvases.cursor.clearRect(0, 0, window.innerWidth, window.innerHeight);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                
                // å…³é”®ç‚¹: é£ŸæŒ‡å°–(8), æ‹‡æŒ‡å°–(4)
                // æ³¨æ„ï¼šå› ä¸º video å’Œ bone å±‚è¢« CSS ç¿»è½¬äº†ï¼Œä½†æˆ‘ä»¬åœ¨ JS é‡Œè®¡ç®— cursor å’Œ painting åæ ‡æ—¶
                // éœ€è¦æ‰‹åŠ¨å¤„ç†é•œåƒï¼Œä»¥ä¾¿è®© cursor å’Œç”»é¢é€»è¾‘åŒ¹é…ã€‚
                
                // è®¡ç®—åŸå§‹å±å¹•åæ ‡ (é•œåƒå)
                const targetX = (1 - lm[8].x) * window.innerWidth;
                const targetY = lm[8].y * window.innerHeight;
                const thumbX = (1 - lm[4].x) * window.innerWidth;
                const thumbY = lm[4].y * window.innerHeight;

                // --- A. åæ ‡å¹³æ»‘ (æ ¸å¿ƒé˜²æŠ–) ---
                if (currPos.x === 0 && currPos.y === 0) {
                    currPos.x = targetX; currPos.y = targetY;
                }
                
                // Lerp æ’å€¼ï¼šå½“å‰ä½ç½®é€æ¸è¶‹å‘ç›®æ ‡ä½ç½®
                currPos.x = lerp(currPos.x, targetX, SMOOTHING_FACTOR);
                currPos.y = lerp(currPos.y, targetY, SMOOTHING_FACTOR);

                // --- B. çŠ¶æ€åˆ¤å®š (æåˆ vs å¼ å¼€) ---
                // è®¡ç®—å½’ä¸€åŒ–åæ ‡çš„è·ç¦» (ä¸å—å±å¹•åˆ†è¾¨ç‡å½±å“)
                const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                const isPinchingNow = pinchDist < PINCH_THRESHOLD;

                // --- C. ç»˜åˆ¶å…‰æ ‡ ---
                // å…‰æ ‡æ€»æ˜¯æ˜¾ç¤ºï¼Œä½†æ ¹æ®çŠ¶æ€æ”¹å˜é¢œè‰²
                canvases.cursor.beginPath();
                canvases.cursor.arc(currPos.x, currPos.y, state.brushSize / 2, 0, Math.PI * 2);
                
                if (!state.hasStarted) {
                    // é”å®šçŠ¶æ€
                    canvases.cursor.strokeStyle = 'red';
                    canvases.cursor.stroke();
                    canvases.cursor.fillStyle = 'rgba(255,0,0,0.2)';
                    canvases.cursor.fill();
                } else if (isPinchingNow) {
                    // æåˆï¼ˆæ¿€æ´»ï¼‰çŠ¶æ€
                    canvases.cursor.fillStyle = document.getElementById('colorPicker').value;
                    canvases.cursor.fill();
                    canvases.cursor.lineWidth = 2;
                    canvases.cursor.strokeStyle = 'white';
                    canvases.cursor.stroke();
                } else {
                    // æ‚¬åœï¼ˆæŠ¬ç¬”ï¼‰çŠ¶æ€
                    canvases.cursor.strokeStyle = '#00ff88';
                    canvases.cursor.lineWidth = 2;
                    canvases.cursor.stroke();
                }

                // æ£€æµ‹UIæ‚¬åœ (å§‹ç»ˆå…è®¸ï¼Œæ–¹ä¾¿åˆ‡æ¢)
                updateHover(currPos.x, currPos.y);

                // --- D. åŠŸèƒ½é€»è¾‘ ---
                
                // åªæœ‰é€‰æ‹©äº†ç”»ç¬”åæ‰æ‰§è¡Œ
                if (state.hasStarted) {
                    if (state.mode === 'draw') {
                        // ç»˜ç”»æ¨¡å¼ï¼šæåˆ = ç”»ï¼Œå¼ å¼€ = åœ
                        if (isPinchingNow) {
                            const brush = BRUSHES[state.brushType];
                            
                            // è®¡ç®—ç›¸å¯¹äºç”»å¸ƒçš„åæ ‡ (å‡å»ä½ç§»)
                            const dx = currPos.x - offset.x;
                            const dy = currPos.y - offset.y;

                            if (!state.isPinching) {
                                // åˆšå¼€å§‹æåˆ (è½ç¬”ç¬é—´)
                                state.isPinching = true;
                                prevPos = { x: dx, y: dy };
                            } else {
                                // æŒç»­æåˆ (ç»˜åˆ¶ä¸­)
                                canvases.draw.beginPath();
                                canvases.draw.moveTo(prevPos.x, prevPos.y);
                                // ä½¿ç”¨äºŒæ¬¡è´å¡å°”æ›²çº¿è¿›ä¸€æ­¥å¹³æ»‘ (å¯é€‰ï¼Œè¿™é‡Œç”¨ç›´çº¿+lerpå·²ç»å¾ˆå¥½äº†)
                                canvases.draw.lineTo(dx, dy);
                                
                                canvases.draw.strokeStyle = document.getElementById('colorPicker').value;
                                canvases.draw.lineWidth = state.brushSize * brush.widthMult;
                                canvases.draw.lineCap = brush.cap;
                                canvases.draw.globalAlpha = brush.alpha;
                                if (brush.shadow > 0) {
                                    canvases.draw.shadowBlur = brush.shadow;
                                    canvases.draw.shadowColor = canvases.draw.strokeStyle;
                                } else {
                                    canvases.draw.shadowBlur = 0;
                                }
                                
                                canvases.draw.stroke();
                                canvases.draw.globalAlpha = 1.0; // è¿˜åŸ
                                prevPos = { x: dx, y: dy };
                            }
                        } else {
                            state.isPinching = false;
                        }

                    } else if (state.mode === 'move') {
                        // ç§»åŠ¨æ¨¡å¼
                        if (isPinchingNow) {
                            if (!state.isPinching) {
                                state.isPinching = true;
                                startPinchPos = { x: currPos.x, y: currPos.y };
                            } else {
                                const dx = currPos.x - startPinchPos.x;
                                const dy = currPos.y - startPinchPos.y;
                                offset.x += dx;
                                offset.y += dy;
                                document.getElementById('drawing_canvas').style.transform = `translate(${offset.x}px, ${offset.y}px)`;
                                startPinchPos = { x: currPos.x, y: currPos.y };
                            }
                            // è§†è§‰åé¦ˆï¼šè¿æ¥çº¿
                            canvases.cursor.beginPath();
                            canvases.cursor.moveTo(currPos.x, currPos.y);
                            canvases.cursor.lineTo(thumbX, thumbY);
                            canvases.cursor.strokeStyle = 'yellow';
                            canvases.cursor.stroke();
                        } else {
                            state.isPinching = false;
                        }
                    }
                }
            }
        }

        // --- å¯åŠ¨ ---
        const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });
        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280, height: 720
        });
        camera.start().then(() => statusEl.innerText = "ç³»ç»Ÿå°±ç»ªï¼Œè¯·é€‰æ‹©ç”»ç¬”");
    </script>
</body>
</html>