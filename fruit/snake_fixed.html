<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>AR æ‰‹åŠ¿è´ªåƒè›‡</title>
  <!-- æ›¿æ¢ä¸º unpkg æº -->
  <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <style>
    body { margin: 0; padding: 0; background-color: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
    #game-container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
    .input_video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
    .output_canvas { position: absolute; width: 100%; height: 100%; transform: scaleX(-1); }
    #ui-layer { position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
    .score-box { position: absolute; top: 20px; left: 30px; color: #2ed573; font-size: 32px; font-weight: bold; text-shadow: 2px 2px 4px black; }
    #center-msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center; text-shadow: 0 0 10px black; z-index: 20; pointer-events: none; }
    h1 { font-size: 80px; margin: 0; }
    p { font-size: 30px; margin-top: 10px; }
    .loading-spinner { border: 8px solid rgba(255,255,255,0.3); border-radius: 50%; border-top: 8px solid #2ed573; width: 60px; height: 60px; animation: spin 1s linear infinite; margin: 0 auto 20px auto; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.85); padding: 40px; border-radius: 20px; text-align: center; backdrop-filter: blur(10px); pointer-events: auto; z-index: 30; border: 2px solid #2ed573; }
    .hidden { display: none !important; }
    .btn { margin-top: 20px; padding: 15px 40px; font-size: 24px; background: #2ed573; color: white; border: none; border-radius: 50px; cursor: pointer; font-weight: bold; }
    .btn:hover { transform: scale(1.05); background: #26af61; }
    .btn-back { background: transparent; border: 2px solid #fff; margin-left: 10px; }
    .btn-back:hover { background: rgba(255,255,255,0.1); }
  </style>
</head>
<body>

<div id="game-container">
  <video class="input_video" playsinline></video>
  <canvas class="output_canvas"></canvas>
  
  <div id="ui-layer">
    <div class="score-box">é•¿åº¦: <span id="score">0</span></div>
  </div>

  <div id="center-msg">
    <div id="loading-panel">
      <div class="loading-spinner"></div>
      <p>æ­£åœ¨åˆå§‹åŒ– AI æ¨¡å‹...</p>
    </div>
    
    <div id="waiting-panel" class="hidden">
      <p style="animation: pulse 1.5s infinite;">ğŸ‘‹ è¯·ä¸¾èµ·ä½ çš„æ‰‹</p>
    </div>

    <h1 id="countdown" class="hidden">3</h1>
  </div>

  <div id="game-over-panel" class="menu hidden">
    <h2 style="color: #ff4757; font-size: 50px; margin:0 0 20px 0;">GAME OVER</h2>
    <p id="death-reason" style="font-size: 24px; color: #ccc;">æ’å‡»åŸå› </p>
    <p style="font-size: 30px; color: white;">æœ€ç»ˆé•¿åº¦: <span id="final-score" style="color: #2ed573;">0</span></p>
    <div style="margin-top: 30px;">
      <button class="btn" onclick="resetGame()">å†ç©ä¸€æ¬¡</button>
      <button class="btn btn-back" onclick="goBack()">è¿”å›ä¸»ä¸–ç•Œ</button>
    </div>
  </div>
</div>

<script>
  const SoundManager = {
    ctx: null,
    init: function() {
      if (!this.ctx) {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
      }
      if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    playEat: function() {
      if (!this.ctx) return;
      const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
      osc.type = 'sine'; osc.frequency.setValueAtTime(200, this.ctx.currentTime);
      osc.frequency.linearRampToValueAtTime(600, this.ctx.currentTime + 0.1);
      gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
      osc.connect(gain); gain.connect(this.ctx.destination);
      osc.start(); osc.stop(this.ctx.currentTime + 0.1);
    },
    playCrash: function() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + 0.3);
    }
  };

  const videoElement = document.getElementsByClassName('input_video')[0];
  const canvasElement = document.getElementsByClassName('output_canvas')[0];
  const ctx = canvasElement.getContext('2d');
  const scoreEl = document.getElementById('score');
  const loadingPanel = document.getElementById('loading-panel');
  const waitingPanel = document.getElementById('waiting-panel');
  const countdownEl = document.getElementById('countdown');
  const gameOverPanel = document.getElementById('game-over-panel');

  let state = 'LOADING';
  let trail = []; let maxTrailLength = 20;
  let headPos = { x: -1, y: -1 }; let targetPos = { x: -1, y: -1 }; 
  let food = { x: 0.5, y: 0.5, type: 'ğŸ' };
  const LERP_FACTOR = 0.15; const MIN_DIST = 5; 
  let isModelLoaded = false;

  // UNPKG Fix
  const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
  hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.4, minTrackingConfidence: 0.4 });
  
  hands.onResults((results) => {
    canvasElement.width = window.innerWidth;
    canvasElement.height = window.innerHeight;
    const W = canvasElement.width; const H = canvasElement.height;
    ctx.clearRect(0, 0, W, H);

    if (!isModelLoaded) {
      isModelLoaded = true;
      state = 'WAITING_HAND';
      loadingPanel.classList.add('hidden');
      waitingPanel.classList.remove('hidden');
      SoundManager.init();
    }
    
    let detected = false; let rawLandmarks = null;
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        detected = true;
        rawLandmarks = results.multiHandLandmarks[0];
        const indexTip = rawLandmarks[8]; 
        targetPos = mapCoordinates(indexTip, videoElement, W, H);
    }

    if (state === 'WAITING_HAND') {
        if (detected) {
            drawSkeleton(rawLandmarks, W, H);
            startCountdown();
        }
    } else if (state === 'COUNTDOWN') {
        if (detected) {
            drawSkeleton(rawLandmarks, W, H);
            ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(targetPos.x, targetPos.y, 15, 0, 2*Math.PI); ctx.fill();
        }
    } else if (state === 'PLAYING') {
        if (!detected) {
            ctx.fillStyle = "rgba(0,0,0,0.3)"; ctx.fillRect(0,0,W,H);
            ctx.fillStyle = "white"; ctx.font="30px Arial"; ctx.textAlign="center"; ctx.fillText("âœ‹ æ‰‹æŒä¸¢å¤±", W/2, H/2);
        } else {
            updateGame(W, H);
        }
    } else if (state === 'GAMEOVER') {
        drawSnake(W, H); drawFood(W, H);
    }
  });

  const camera = new Camera(videoElement, {
    onFrame: async () => { if(videoElement.videoWidth) await hands.send({image: videoElement}); },
    width: 1280, height: 720
  });
  camera.start();

  function mapCoordinates(point, video, canvasW, canvasH) {
    const videoW = video.videoWidth || 1280; const videoH = video.videoHeight || 720;
    const videoAspect = videoW / videoH; const screenAspect = canvasW / canvasH;
    let scale, offsetX, offsetY;
    if (screenAspect > videoAspect) {
        scale = canvasW / videoW;
        const visibleVideoH = canvasH / scale;
        offsetY = (videoH - visibleVideoH) / 2; offsetX = 0;
    } else {
        scale = canvasH / videoH;
        const visibleVideoW = canvasW / scale;
        offsetX = (videoW - visibleVideoW) / 2; offsetY = 0;
    }
    const pixelX = point.x * videoW; const pixelY = point.y * videoH;
    const finalX = (pixelX - offsetX) * scale; const finalY = (pixelY - offsetY) * scale;
    return { x: finalX, y: finalY };
  }

  function startCountdown() {
    SoundManager.init();
    state = 'COUNTDOWN';
    waitingPanel.classList.add('hidden');
    countdownEl.classList.remove('hidden');
    let count = 3;
    countdownEl.innerText = count;
    headPos = { ...targetPos }; trail = [];
    let timer = setInterval(() => {
        count--;
        if (count > 0) { countdownEl.innerText = count; } 
        else { clearInterval(timer); countdownEl.classList.add('hidden'); startGame(); }
    }, 1000);
  }

  function startGame() {
    state = 'PLAYING'; maxTrailLength = 30; trail = [];
    trail.push({x: headPos.x, y: headPos.y});
    spawnFood(); updateScore();
  }

  function updateGame(W, H) {
    headPos.x += (targetPos.x - headPos.x) * LERP_FACTOR;
    headPos.y += (targetPos.y - headPos.y) * LERP_FACTOR;
    const lastPoint = trail[trail.length - 1];
    const distMoved = Math.hypot(headPos.x - lastPoint.x, headPos.y - lastPoint.y);
    if (distMoved > MIN_DIST) {
        trail.push({ x: headPos.x, y: headPos.y });
        if (trail.length > maxTrailLength) trail.shift();
    }
    drawFood(W, H); drawSnake(W, H); checkCollisions(W, H);
  }

  function drawSkeleton(landmarks, W, H) {
    ctx.save(); ctx.strokeStyle = "rgba(0, 255, 0, 0.5)"; ctx.lineWidth = 2;
    for (const connection of HAND_CONNECTIONS) {
        const p1 = landmarks[connection[0]]; const p2 = landmarks[connection[1]];
        const c1 = mapCoordinates(p1, videoElement, W, H); const c2 = mapCoordinates(p2, videoElement, W, H);
        ctx.beginPath(); ctx.moveTo(c1.x, c1.y); ctx.lineTo(c2.x, c2.y); ctx.stroke();
    }
    ctx.restore();
  }

  function drawSnake(W, H) {
    if (trail.length < 2) return;
    ctx.lineCap = "round"; ctx.lineJoin = "round";
    ctx.lineWidth = 20; ctx.beginPath(); ctx.moveTo(trail[0].x, trail[0].y);
    for (let i = 1; i < trail.length; i++) {
        const xc = (trail[i].x + trail[i-1].x) / 2;
        const yc = (trail[i].y + trail[i-1].y) / 2;
        ctx.quadraticCurveTo(trail[i-1].x, trail[i-1].y, xc, yc);
    }
    ctx.lineTo(trail[trail.length-1].x, trail[trail.length-1].y);
    const gradient = ctx.createLinearGradient(trail[0].x, trail[0].y, headPos.x, headPos.y);
    gradient.addColorStop(0, "#2ed573"); gradient.addColorStop(1, "#7bed9f");
    ctx.strokeStyle = gradient; ctx.stroke();
    ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(headPos.x, headPos.y, 15, 0, 2*Math.PI); ctx.fill();
    ctx.fillStyle = "#000";
    ctx.beginPath(); ctx.arc(headPos.x - 5, headPos.y - 5, 4, 0, 2*Math.PI); ctx.fill();
    ctx.beginPath(); ctx.arc(headPos.x + 5, headPos.y - 5, 4, 0, 2*Math.PI); ctx.fill();
  }

  function drawFood(W, H) {
    ctx.font = "40px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
    ctx.fillText(food.type, food.x * W, food.y * H);
  }

  function checkCollisions(W, H) {
      const fx = food.x * W; const fy = food.y * H;
      if (Math.hypot(headPos.x - fx, headPos.y - fy) < 40) {
          SoundManager.playEat();
          maxTrailLength += 15; spawnFood(); updateScore();
      }
      if (headPos.x < 20 || headPos.x > W - 20 || headPos.y < 20 || headPos.y > H - 20) {
          SoundManager.playCrash();
          endGame("æ’åˆ°å¢™å£äº†!");
      }
      const safeZone = 20; 
      if (trail.length > safeZone) {
          for (let i = 0; i < trail.length - safeZone; i++) {
              if (Math.hypot(headPos.x - trail[i].x, headPos.y - trail[i].y) < 10) {
                  SoundManager.playCrash();
                  endGame("å’¬åˆ°è‡ªå·±äº†!"); break;
              }
          }
      }
  }

  function spawnFood() {
      food = { x: 0.1 + Math.random() * 0.8, y: 0.1 + Math.random() * 0.8, type: ['ğŸ','ğŸ“','ğŸ‡','ğŸŠ'][Math.floor(Math.random()*4)] };
  }

  function updateScore() { scoreEl.innerText = Math.floor(maxTrailLength - 30); }

  function endGame(reason) {
      state = 'GAMEOVER';
      document.getElementById('death-reason').innerText = reason;
      document.getElementById('final-score').innerText = Math.floor(maxTrailLength - 30);
      gameOverPanel.classList.remove('hidden');
  }

  function resetGame() {
      gameOverPanel.classList.add('hidden');
      state = 'WAITING_HAND'; waitingPanel.classList.remove('hidden');
  }

  function goBack() { window.location.href = 'index.html'; }
</script>
</body>
</html>